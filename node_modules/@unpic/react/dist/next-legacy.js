"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/next-legacy.tsx
var next_legacy_exports = {};
__export(next_legacy_exports, {
  Image: () => Image3
});
module.exports = __toCommonJS(next_legacy_exports);
var import_react = require("react");

// src/image.tsx
var React = __toESM(require("react"));
var import_core = require("@unpic/core");

// src/camelize.ts
var nestedKeys = /* @__PURE__ */ new Set(["style"]);
var fixedMap = {
  srcset: "srcSet",
  fetchpriority: "fetchPriority"
};
var camelize = (key) => {
  if (key.startsWith("data-") || key.startsWith("aria-")) {
    return key;
  }
  return fixedMap[key] || key.replace(/-./g, (suffix) => suffix[1].toUpperCase());
};
function camelizeProps(props) {
  return Object.fromEntries(
    Object.entries(props).map(([k, v]) => [
      camelize(k),
      nestedKeys.has(k) && v && typeof v !== "string" ? camelizeProps(v) : v
    ])
  );
}

// src/image.tsx
var import_jsx_runtime = require("react/jsx-runtime");
var Image = React.forwardRef(
  function Image2(props, ref) {
    const camelizedProps = camelizeProps((0, import_core.transformProps)(props));
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("img", { ...camelizedProps, ref });
  }
);

// src/source.tsx
var React2 = __toESM(require("react"));
var import_core2 = require("@unpic/core");
var import_jsx_runtime2 = require("react/jsx-runtime");
var Source = React2.forwardRef(
  function Source2(props, ref) {
    const camelizedProps = camelizeProps(
      (0, import_core2.transformSourceProps)(
        props
      )
    );
    return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("source", { ...camelizedProps, ref });
  }
);

// ../../node_modules/.pnpm/unpic@3.17.0/node_modules/unpic/esm/data/domains.js
var domains_default = {
  "images.ctfassets.net": "contentful",
  "cdn.builder.io": "builder.io",
  "images.prismic.io": "imgix",
  "www.datocms-assets.com": "imgix",
  "cdn.sanity.io": "imgix",
  "images.unsplash.com": "imgix",
  "cdn.shopify.com": "shopify",
  "s7d1.scene7.com": "scene7",
  "ip.keycdn.com": "keycdn",
  "assets.caisy.io": "bunny",
  "images.contentstack.io": "contentstack",
  "ucarecdn.com": "uploadcare"
};

// ../../node_modules/.pnpm/unpic@3.17.0/node_modules/unpic/esm/data/subdomains.js
var subdomains_default = {
  "imgix.net": "imgix",
  "files.wordpress.com": "wordpress",
  "b-cdn.net": "bunny",
  "storyblok.com": "storyblok",
  "kc-usercontent.com": "kontent.ai",
  "cloudinary.com": "cloudinary",
  "kxcdn.com": "keycdn",
  "imgeng.in": "imageengine",
  "imagekit.io": "imagekit",
  "cloudimg.io": "cloudimage",
  "ucarecdn.com": "uploadcare"
};

// ../../node_modules/.pnpm/unpic@3.17.0/node_modules/unpic/esm/data/paths.js
var paths_default = {
  "/cdn-cgi/image/": "cloudflare",
  "/cdn-cgi/imagedelivery/": "cloudflare_images",
  "/_next/image": "nextjs",
  "/_next/static": "nextjs",
  "/_vercel/image": "vercel",
  "/is/image": "scene7",
  "/_ipx/": "ipx",
  "/_image": "astro",
  "/.netlify/images": "netlify"
};

// ../../node_modules/.pnpm/unpic@3.17.0/node_modules/unpic/esm/src/utils.js
var toUrl = (url, base) => {
  return typeof url === "string" ? new URL(url, base ?? "http://n/") : url;
};

// ../../node_modules/.pnpm/unpic@3.17.0/node_modules/unpic/esm/src/detect.js
var cdnDomains = new Map(Object.entries(domains_default));
var cdnSubdomains = Object.entries(subdomains_default);
function getImageCdnForUrl(url) {
  return getImageCdnForUrlByDomain(url) || getImageCdnForUrlByPath(url);
}
function getImageCdnForUrlByDomain(url) {
  if (typeof url === "string" && !url.startsWith("https://")) {
    return false;
  }
  const { hostname } = toUrl(url);
  if (cdnDomains.has(hostname)) {
    return cdnDomains.get(hostname);
  }
  for (const [subdomain, cdn] of cdnSubdomains) {
    if (hostname.endsWith(`.${subdomain}`)) {
      return cdn;
    }
  }
  return false;
}
function getImageCdnForUrlByPath(url) {
  const { pathname } = toUrl(url);
  for (const [prefix, cdn] of Object.entries(paths_default)) {
    if (pathname.startsWith(prefix)) {
      return cdn;
    }
  }
  return false;
}

// src/next-legacy.tsx
var import_image_config = require("next/dist/shared/lib/image-config.js");
var import_image_config_context = require("next/dist/shared/lib/image-config-context.js");
var import_jsx_runtime3 = require("react/jsx-runtime");
var configEnv = process.env.__NEXT_IMAGE_OPTS;
function checkMatchingPatterns(config, src) {
  if (
    // match-remote-pattern doesn't support the edge runtime
    process.env.NEXT_RUNTIME === "edge" || // we don't have access to the image domains/remotePatterns in production
    process.env.NODE_ENV !== "development"
  ) {
    return;
  }
  if (!src?.startsWith("http://") && !src?.startsWith("https://")) {
    return;
  }
  let parsedSrc;
  try {
    parsedSrc = new URL(src);
  } catch (err) {
    console.error(err);
    return;
  }
  import("next/dist/shared/lib/match-remote-pattern").then(({ hasMatch }) => {
    if (!hasMatch(config.domains, config.remotePatterns, parsedSrc)) {
      throw new Error(
        `[Unpic]: Invalid src (${src}). Images that aren't on a supported image CDN must be configured under images in your \`next.config.js\`
See more info: https://nextjs.org/docs/messages/next-image-unconfigured-host`
      );
    }
  });
}
function getImageData(src) {
  if (typeof src === "string") {
    return;
  }
  if ("default" in src) {
    return src.default;
  }
  return src;
}
var Image3 = (0, import_react.forwardRef)(
  function Image4(props, ref) {
    const configContext = (0, import_react.useContext)(import_image_config_context.ImageConfigContext);
    const config = configEnv || configContext || import_image_config.imageConfigDefault;
    const breakpoints = (0, import_react.useMemo)(() => {
      return [...config.deviceSizes, ...config.imageSizes];
    }, [config]);
    const { src: origSrc, ...rest } = props;
    const childProps = rest;
    const imageData = getImageData(origSrc);
    const src = imageData?.src || origSrc;
    if (imageData && props.layout !== "fullWidth") {
      if (!childProps.width) {
        if (childProps.height) {
          childProps.width = childProps.aspectRatio ? childProps.height * childProps.aspectRatio : childProps.height * (imageData.width / imageData.height);
        } else {
          childProps.width = imageData.width;
        }
      }
      if (!childProps.height) {
        if (childProps.width) {
          childProps.height = childProps.aspectRatio ? childProps.width / childProps.aspectRatio : childProps.width * (imageData.height / imageData.width);
        } else {
          childProps.height = imageData.height;
        }
      }
    }
    childProps.background ||= imageData?.blurDataURL;
    const cdn = (0, import_react.useMemo)(() => {
      if (src?.startsWith("/")) {
        return "nextjs";
      }
      return getImageCdnForUrl(src);
    }, [src]);
    const isRemoteCdn = cdn && cdn !== "nextjs" && cdn !== "vercel";
    (0, import_react.useEffect)(() => {
      if (!src || !config || isRemoteCdn) {
        return;
      }
      checkMatchingPatterns(config, src);
    }, [src, isRemoteCdn, config]);
    if (isRemoteCdn) {
      return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(Image, { ...childProps, src, ref });
    }
    return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
      Image,
      {
        ...childProps,
        src,
        ref,
        breakpoints,
        cdn: "nextjs"
      }
    );
  }
);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Image
});
