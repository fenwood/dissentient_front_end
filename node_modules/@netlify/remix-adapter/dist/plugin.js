"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/plugin.ts
var plugin_exports = {};
__export(plugin_exports, {
  netlifyPlugin: () => netlifyPlugin
});
module.exports = __toCommonJS(plugin_exports);
var import_promises = require("fs/promises");
var import_node_path = require("path");
var import_posix = require("path/posix");

// package.json
var name = "@netlify/remix-adapter";
var version = "2.4.0";

// src/plugin.ts
var SERVER_ID = "virtual:netlify-server";
var RESOLVED_SERVER_ID = `\0${SERVER_ID}`;
var toPosixPath = (path) => path.split(import_node_path.sep).join(import_posix.sep);
var serverCode = (
  /* js */
  `
import { createRequestHandler } from "@netlify/remix-adapter";
import * as build from "virtual:remix/server-build";
export default createRequestHandler({ build });
`
);
function generateNetlifyFunction(server) {
  return (
    /* js */
    `
    export { default } from "${server}";
    export const config = {
      name: "Remix server handler",
      generator: "${name}@${version}",
      path: "/*",
      preferStatic: true,
    };
    `
  );
}
function netlifyPlugin() {
  let resolvedConfig;
  let currentCommand;
  let isSsr;
  return {
    name: "vite-plugin-remix-netlify-functions",
    config(config, { command, isSsrBuild }) {
      var _a, _b;
      currentCommand = command;
      isSsr = isSsrBuild;
      if (command === "build") {
        if (isSsrBuild) {
          if (typeof ((_b = (_a = config.build) == null ? void 0 : _a.rollupOptions) == null ? void 0 : _b.input) === "string") {
            config.build.rollupOptions.input = {
              server: SERVER_ID,
              index: config.build.rollupOptions.input
            };
            if (config.build.rollupOptions.output && !Array.isArray(config.build.rollupOptions.output)) {
              config.build.rollupOptions.output.entryFileNames = "[name].js";
            }
          }
        }
      }
    },
    async resolveId(source) {
      if (source === SERVER_ID) {
        return RESOLVED_SERVER_ID;
      }
    },
    load(id) {
      if (id === RESOLVED_SERVER_ID) {
        return serverCode;
      }
    },
    async configResolved(config) {
      resolvedConfig = config;
    },
    async writeBundle() {
      if (currentCommand === "build" && isSsr) {
        const functionsDirectory = (0, import_node_path.join)(resolvedConfig.root, ".netlify/functions-internal");
        await (0, import_promises.mkdir)(functionsDirectory, { recursive: true });
        const serverPath = (0, import_node_path.join)(resolvedConfig.build.outDir, "server.js");
        const relativeServerPath = toPosixPath((0, import_node_path.relative)(functionsDirectory, serverPath));
        await (0, import_promises.writeFile)((0, import_node_path.join)(functionsDirectory, "remix-server.mjs"), generateNetlifyFunction(relativeServerPath));
      }
    }
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  netlifyPlugin
});
