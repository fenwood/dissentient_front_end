"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleRequest = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const node_stream_1 = require("node:stream");
const node_1 = require("@remix-run/node");
const react_1 = require("@remix-run/react");
const isbot_1 = __importDefault(require("isbot"));
const server_1 = require("react-dom/server");
const ABORT_DELAY = 5000;
function handleRequest(request, responseStatusCode, responseHeaders, remixContext, loadContext) {
    const bot = (0, isbot_1.default)(request.headers.get('user-agent'));
    return new Promise((resolve, reject) => {
        let shellRendered = false;
        const body = new node_stream_1.PassThrough();
        const stream = (0, node_1.createReadableStreamFromReadable)(body);
        const { pipe, abort } = (0, server_1.renderToPipeableStream)((0, jsx_runtime_1.jsx)(react_1.RemixServer, { context: remixContext, url: request.url, abortDelay: ABORT_DELAY }), {
            onShellReady() {
                if (!bot) {
                    shellRendered = true;
                    responseHeaders.set('Content-Type', 'text/html');
                    resolve(new Response(stream, {
                        headers: responseHeaders,
                        status: responseStatusCode,
                    }));
                    pipe(body);
                }
            },
            onShellError(error) {
                reject(error);
            },
            onAllReady() {
                // Avoid a bug where responses aren't flushed if there's an outstanding timer.
                clearTimeout(timer);
                if (bot) {
                    shellRendered = true;
                    responseHeaders.set('Content-Type', 'text/html');
                    resolve(new Response(stream, {
                        headers: responseHeaders,
                        status: responseStatusCode,
                    }));
                    pipe(body);
                }
            },
            onError(error) {
                responseStatusCode = 500;
                // Log streaming rendering errors from inside the shell.  Don't log
                // errors encountered during initial shell rendering since they'll
                // reject and get logged in handleDocumentRequest.
                if (shellRendered) {
                    console.error(error);
                }
            },
        });
        const timer = setTimeout(() => {
            abort();
        }, ABORT_DELAY);
    });
}
exports.handleRequest = handleRequest;
